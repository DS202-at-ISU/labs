<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>DS 202 - lab #4: Scraping (into) the Hall of Fame</title>
    <meta charset="utf-8" />
    <meta name="author" content="Heike Hofmann" />
    <script src="libs/header-attrs-2.18/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# DS 202 - lab #4: Scraping (into) the Hall of Fame
]
.author[
### Heike Hofmann
]

---

class: center, bottom, inverse
background-image: url(images/hof.jpg)



&lt;!--&lt;img src="" class="cover" height=1500&gt;--&gt;

# Lab #4: Scraping (into) the Hall of Fame
---

# Big Picture Goal

We are going to contribute an extension of the Hall of Fame data in the Lahman data package for the years 2019 to 2022.

# Step-by-Step

In this activity we are going to

1. identify suitable websites with data on Baseball's Hall of Fame
2. write web scrapers with the goal to 
    
    a. automate the download process, 
    b. and - as much as possible - clean the data automatically, or at least identify potential problems, to, finally, 
    b. use the scrapers in future years
    
3. use the scraper to get data for the years 2019 to 2022.
4. document the process. 

The deliverables are (1) a README file with a filled in table, (2) individual reports (Rmd) and (3) the dataset.

---

# Getting Ready

1. Identify your team! Go to Canvas and find out your team  for Lab 4. There are 12 teams with 3 or 4 members.

2. Join the zoom break-out room that has the same number as your team. 
If you are in the classroom, find the other members of your team and sit with them.

3. Introduce yourself to each other. 

4. Go to https://ds202-at-isu.github.io/labs/lab04.html and follow the instructions.


In case of questions: if you are on zoom, you can leave the breakout room and ask a question. In the classroom make yourself noticed :)

---

# Step-by Step

1. Accept the link to Github Classroom shared in the announcement/chat. 
  
  - This link will ask you to log in to github. Select your name from the list by clicking on it.  
&lt;!-- https://classroom.github.com/a/pfl2YPZY--&gt;
  - Check if your team number already exists - if it does, join the team with the right number. If it doesn't exist yet, create it yourself.

2. Start a new RStudio project on your local machine using the link to the github repository.

3. Create a new RMarkdown file called `progress-report-&lt;your github handle&gt;.Rmd` (Mine would be called `progress-report-heike.Rmd`). Delete everything from line 12 on. 

4. Save the file and add it to your github repository. 

5. Use this RMarkdown file for your lab notes - try to keep track of what you are doing, so you have an easier time afterward to see what worked and what didn't.

4. Commit the file and push. We are ready to roll!


---

# Data Background

The Lahman data package is based on [Sean Lahman](https://www.seanlahman.com/)'s  Baseball  [Database](https://www.seanlahman.com/baseball-archive/statistics/). 

The `HallOfFame` table is a part of this set of tables and  has [not been updated since 2018](https://github.com/chadwickbureau/baseballdatabank/commits/a0b17f910506f7bfc2be2f834c50d50beb884c8f/core/HallOfFame.csv?browsing_rename_history=true&amp;new_path=contrib/HallOfFame.csv&amp;original_branch=master)

## Baseball Reference 

The site baseball-reference.com has grown out of Sean Lahman's work and is now maintained independently. 

Incidentally, it also has tables with Hall of Fame information, e.g. for 2022: 

https://www.baseball-reference.com/awards/hof_2022.shtml

---
# Scrape the data

Use the `rvest` package to download and parse data tables for Hall of Fame voting records. 

# Clean the data

What steps are necessary to get the scraped data into the shape as the `HallOfFame` data table:


```r
library(Lahman)
head(HallOfFame, 3)
```

```
##    playerID yearID votedBy ballots needed votes inducted
## 1  cobbty01   1936   BBWAA     226    170   222        Y
## 2  ruthba01   1936   BBWAA     226    170   215        Y
## 3 wagneho01   1936   BBWAA     226    170   215        Y
##   category needed_note
## 1   Player        &lt;NA&gt;
## 2   Player        &lt;NA&gt;
## 3   Player        &lt;NA&gt;
```
---

# Deliverable: data

As a team, create the Hall of fame data for the years 2019 to 2022.

Save the result by appending the new data frame(s) to the existing data `HallOfFame.csv` in your repo.


```r
HallOfFame %&gt;% 
  ggplot(aes(x = yearID, fill = inducted)) +
  geom_bar() +
  xlim(c(1936, 2022))
```

![](lab04_files/figure-html/unnamed-chunk-2-1.png)&lt;!-- --&gt;

---

# Some Data Tidying tricks



Should you be in the situation, that a data set does not have any names, but the names are stored as the first line of records:


```r
head(tables[[1]], 3)
```

```
## # A tibble: 3 × 39
##   ``    ``       ``    ``    ``    ``    ``    ``    ``    ``   
##   &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
## 1 Rk    Name     YoB   Votes %vote HOFm  HOFs  Yrs   WAR   WAR7 
## 2 1     David O… 1st   307   77.9% 171   55    20    55.3  35.2 
## 3 2     X-Barry… 10th  260   66.0% 340   77    22    162.8 72.7 
## # … with 29 more variables: `` &lt;chr&gt;, `` &lt;chr&gt;,
## #   `Batting Stats` &lt;chr&gt;, `Batting Stats` &lt;chr&gt;,
## #   `Batting Stats` &lt;chr&gt;, `Batting Stats` &lt;chr&gt;,
## #   `Batting Stats` &lt;chr&gt;, `Batting Stats` &lt;chr&gt;,
## #   `Batting Stats` &lt;chr&gt;, `Batting Stats` &lt;chr&gt;,
## #   `Batting Stats` &lt;chr&gt;, `Batting Stats` &lt;chr&gt;,
## #   `Batting Stats` &lt;chr&gt;, `Batting Stats` &lt;chr&gt;, …
```
---

# Variable Names in Line 2

Write the dataset into a temporary file, and read the data back in (using the command `read_csv`) and skipping the first line:


```r
write.csv(tables[[1]], "temp.csv", row.names=FALSE)
backin &lt;- readr::read_csv("temp.csv", skip = 1, show_col_types =FALSE)
head(backin, 3)
```

```
## # A tibble: 3 × 39
##      Rk Name   YoB   Votes `%vote`  HOFm  HOFs   Yrs   WAR  WAR7
##   &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1 David… 1st     307 77.9%     171    55    20  55.3  35.2
## 2     2 X-Bar… 10th    260 66.0%     340    77    22 163.   72.7
## 3     3 X-Rog… 10th    257 65.2%     332    73    24 139.   65.9
## # … with 29 more variables: JAWS &lt;dbl&gt;, Jpos &lt;dbl&gt;,
## #   G...13 &lt;dbl&gt;, AB &lt;dbl&gt;, R &lt;dbl&gt;, H...16 &lt;dbl&gt;,
## #   HR...17 &lt;dbl&gt;, RBI &lt;dbl&gt;, SB &lt;dbl&gt;, BB...20 &lt;dbl&gt;,
## #   BA &lt;dbl&gt;, OBP &lt;dbl&gt;, SLG &lt;dbl&gt;, OPS &lt;dbl&gt;, `OPS+` &lt;dbl&gt;,
## #   W &lt;dbl&gt;, L &lt;dbl&gt;, ERA &lt;dbl&gt;, `ERA+` &lt;dbl&gt;, WHIP &lt;dbl&gt;,
## #   G...31 &lt;dbl&gt;, GS &lt;dbl&gt;, SV &lt;dbl&gt;, IP &lt;dbl&gt;, H...35 &lt;dbl&gt;,
## #   HR...36 &lt;dbl&gt;, BB...37 &lt;dbl&gt;, SO &lt;dbl&gt;, …
```
---

# Functions you might need

**`parse_number`** from the `readr` package


```r
readr::parse_number(c("34%", "10th", "1.0"))
```

```
## [1] 34 10  1
```

**`gsub`** from R base: 

Usage `gsub(pattern, replacement, x)`:  replace all occurrences of `pattern` in vector `x` by the string `replacement`. 


```r
x &lt;- c("David Ortiz", "X-Barry Bonds", "X-Roger Clemens")

gsub("X-", "Oh no! ", x)
```

```
## [1] "David Ortiz"          "Oh no! Barry Bonds"  
## [3] "Oh no! Roger Clemens"
```

```r
gsub("X-", "", x)
```

```
## [1] "David Ortiz"   "Barry Bonds"   "Roger Clemens"
```
---

# Combining Data sets

If two data frames have the same variable names, we can use the command **`rbind`** (row bind) to concatenate them. 


```r
x1 &lt;- data.frame(id=1:2, name=c("A", "B"))
x2 &lt;- data.frame(id=3:4, name=c("C", "D"))

rbind(x1, x2)
```

```
##   id name
## 1  1    A
## 2  2    B
## 3  3    C
## 4  4    D
```

```r
dframe &lt;- rbind(x1, x2)
```
Don't forget to save the result!

---

# Exporting csv files

**`write.csv`** writes a data frame into a comma-separated values file (extension csv):


```r
write.csv(dframe, file="some-file.csv", row.names = FALSE)
```

Make sure to not export the row names, otherwise each successive read &amp; write of the file adds another column in the front.



**`write_csv`** is not part of base, but faster, and does not convert special characters into `.`



```r
readr::write_csv(dframe, file="some-other-file.csv")
```

---

# Submission

1. Push changes to your file `progress-report-&lt;github handle&gt;.Rmd` to the github repo. 

2. Fill out the table in  `README.Rmd.` Knit the `README.Rmd` to create a file `README.md`. 
Push all of those changes to the repo.

3. Push the expanded `HallOfFame.csv` to the team's repository.



Due date: You have time until Monday, Nov 28 at 10 pm to submit the final RMmarkdown file.

One team member: upload the team's repo link to Canvas (just to signal to the instructor that you are done)
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
